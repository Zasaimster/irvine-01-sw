#!/bin/sh
#
#  Take pictures in different scenarios
#    - initial - Take pictures during initial deployment
#    - picture - Take a sequence of picture
#    - position - Take a picture and feed to star tracker
#
instdir=$(cd "$(dirname "$0")"; pwd)
myProgram=$0
. "${instdir}/log.sh"
log_init "
$0"

logFile=${logFile-/tmp/snap.log}
storageRoot=${storageRoot-/sdcard}

usage()
{
    echo "Snap [-i (initial) | -n {n} (n pics)| -p (position) ]"
}

exitStatus=0

O=$(getopt -- hin:p "$@") || exit 1
eval set -- "$O"

snapExe=${snapExe-"uvccapture"}
starTracker=${starTracker-"/usr/local/bin/solve-field.sh"}
stdArgs="-M -j -A1"

resMin="-x320 -y240"
resLo="-x640 -y480"
resMed="-x1024 -y768"
resHi="-x2048 -y1536"

resArgs=$resStd

callSelfArg="-c$myProgram"

#
# If no command line flags, we are calling ourself with the name
# of the image (via uvccapture).
#
scenario="callself"
numPics=1

#
# store the original scenario here when calling self
#
origScenarioFile="/tmp/origScenario"

#
# hold the index of the current picture
#
pictureIndexFile="/data/picIndex.dat"

while true ; do
    case $1 in 
        -h)
            usage
            exit 0
            ;;
        -i)
            scenario="initial"
            shift
            ;;
        -n)
            numPics="$2"
            resArgs=$resHi
            shift 2
            ;;
        -p)
            scenario="position"
            shift
            ;;
        --)
            shift
            break;
            ;;
        *)
            log "[E] unknown arg:  $arg"
            exit 1
            ;;
    esac
done

#
# if no arguments, take a picture
#
if [ -z "$1" ] && [ $scenario = "callself" ]; then
    scenario="picture"
fi

#
# Run image capture based on the scenario
#
executeScenario()
{
    if [ "$scenario" = "picture" ] && [ -n "$numPics" ]; then
        pictureArg=" - Taking $numPics pictures"
    fi
    log "[I] Snapping $scenario $pictureArg"

    case $scenario in 
        "initial")
            # take pictures with 1 second delay between
            numPics=15
            delay=1
            resArgs=$resHi
            ;;
        "picture")
            resArgs=$resHi
            ;;
        "position")
            resArgs=$resMin
            ;;
        "*")
            log "[E] Unknown scenario $scenario"
            exit 1
            ;;
    esac

    if [ -n "$numPics" ]; then
        numPicsArg="-n$numPics"
    fi

    if [ -n "$delay" ]; then
        delayArg="-D$delay"
    fi
    echo "$scenario">"$origScenarioFile"
    i=0
      while [ $i -lt $numPics ]; do
          $snapExe $stdArgs $resArgs $callSelfArg
          if [ -n "$delay" ]; then
              sleep $delay
          fi
          i=$((i+1))
      done

}

setPicIndex()
{
    if [ -e $pictureIndexFile ]; then
        picIndex=$(cat $pictureIndexFile)
    else
        picIndex=0
    fi
    #
    # increment the index and store it
    #
    picIndex=$((picIndex+1))
    echo "$picIndex" > $pictureIndexFile
}

#
# Clean up temporary files we created
#
cleanup()
{
    rm -f $origScenarioFile 
}

#
# rename picture and then perform further processing if necessary
#
processPicture()
{
    picName=$1
    origScenario=$(cat $origScenarioFile)
    extension=${1##*.}
    
    if [ -z "$origScenario" ]; then
        log "[E] No original scenario found"
        return 1
    fi

    setPicIndex

    #
    # Generate image name with picture index, date and scenario
    #
    storedPictureName=$(printf "%04d-%s-%s.%s" $picIndex $(date +%Y%m%d_%H%M%S) ${origScenario} $extension)

    storageDir="${storageRoot}/$origScenario";
    mkdir -p $storageDir
    storagePath="${storageDir}/$storedPictureName"
    log "[I] Saving $storagePath"
    mv "$picName" "$storagePath"
    
    if [ "$origScenario" = "position" ]; then
        ${starTracker} ${storagePath}
    fi
}

if [ "$scenario" = "callself" ]; then
    processPicture $1
    exitStatus=$?
    log "[I] Done processing picture"
else
    executeScenario
    exitStatus=$?
fi

if [ $exitStatus -ne 0 ]; then
  log "[E] Snap status $exitStatus"
else 
  log "$0 Snap success"
fi

exit "$exitStatus"
